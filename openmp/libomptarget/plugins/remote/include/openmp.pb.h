// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openmp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openmp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openmp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openmp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openmp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openmp_2eproto;
namespace openmp {
namespace libomptarget {
namespace remote {
class AllocData;
struct AllocDataDefaultTypeInternal;
extern AllocDataDefaultTypeInternal _AllocData_default_instance_;
class Binary;
struct BinaryDefaultTypeInternal;
extern BinaryDefaultTypeInternal _Binary_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class DeleteData;
struct DeleteDataDefaultTypeInternal;
extern DeleteDataDefaultTypeInternal _DeleteData_default_instance_;
class DeviceOffloadEntry;
struct DeviceOffloadEntryDefaultTypeInternal;
extern DeviceOffloadEntryDefaultTypeInternal _DeviceOffloadEntry_default_instance_;
class DevicePair;
struct DevicePairDefaultTypeInternal;
extern DevicePairDefaultTypeInternal _DevicePair_default_instance_;
class ExchangeData;
struct ExchangeDataDefaultTypeInternal;
extern ExchangeDataDefaultTypeInternal _ExchangeData_default_instance_;
class I32;
struct I32DefaultTypeInternal;
extern I32DefaultTypeInternal _I32_default_instance_;
class I64;
struct I64DefaultTypeInternal;
extern I64DefaultTypeInternal _I64_default_instance_;
class ImagePtrs;
struct ImagePtrsDefaultTypeInternal;
extern ImagePtrsDefaultTypeInternal _ImagePtrs_default_instance_;
class Null;
struct NullDefaultTypeInternal;
extern NullDefaultTypeInternal _Null_default_instance_;
class Pointer;
struct PointerDefaultTypeInternal;
extern PointerDefaultTypeInternal _Pointer_default_instance_;
class RetrieveData;
struct RetrieveDataDefaultTypeInternal;
extern RetrieveDataDefaultTypeInternal _RetrieveData_default_instance_;
class SubmitData;
struct SubmitDataDefaultTypeInternal;
extern SubmitDataDefaultTypeInternal _SubmitData_default_instance_;
class TargetBinaryDescription;
struct TargetBinaryDescriptionDefaultTypeInternal;
extern TargetBinaryDescriptionDefaultTypeInternal _TargetBinaryDescription_default_instance_;
class TargetDeviceImage;
struct TargetDeviceImageDefaultTypeInternal;
extern TargetDeviceImageDefaultTypeInternal _TargetDeviceImage_default_instance_;
class TargetDeviceImagePtr;
struct TargetDeviceImagePtrDefaultTypeInternal;
extern TargetDeviceImagePtrDefaultTypeInternal _TargetDeviceImagePtr_default_instance_;
class TargetOffloadEntry;
struct TargetOffloadEntryDefaultTypeInternal;
extern TargetOffloadEntryDefaultTypeInternal _TargetOffloadEntry_default_instance_;
class TargetRegion;
struct TargetRegionDefaultTypeInternal;
extern TargetRegionDefaultTypeInternal _TargetRegion_default_instance_;
class TargetTable;
struct TargetTableDefaultTypeInternal;
extern TargetTableDefaultTypeInternal _TargetTable_default_instance_;
class TargetTeamRegion;
struct TargetTeamRegionDefaultTypeInternal;
extern TargetTeamRegionDefaultTypeInternal _TargetTeamRegion_default_instance_;
}  // namespace remote
}  // namespace libomptarget
}  // namespace openmp
PROTOBUF_NAMESPACE_OPEN
template<> ::openmp::libomptarget::remote::AllocData* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::AllocData>(Arena*);
template<> ::openmp::libomptarget::remote::Binary* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::Binary>(Arena*);
template<> ::openmp::libomptarget::remote::Data* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::Data>(Arena*);
template<> ::openmp::libomptarget::remote::DeleteData* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::DeleteData>(Arena*);
template<> ::openmp::libomptarget::remote::DeviceOffloadEntry* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::DeviceOffloadEntry>(Arena*);
template<> ::openmp::libomptarget::remote::DevicePair* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::DevicePair>(Arena*);
template<> ::openmp::libomptarget::remote::ExchangeData* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::ExchangeData>(Arena*);
template<> ::openmp::libomptarget::remote::I32* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::I32>(Arena*);
template<> ::openmp::libomptarget::remote::I64* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::I64>(Arena*);
template<> ::openmp::libomptarget::remote::ImagePtrs* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::ImagePtrs>(Arena*);
template<> ::openmp::libomptarget::remote::Null* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::Null>(Arena*);
template<> ::openmp::libomptarget::remote::Pointer* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::Pointer>(Arena*);
template<> ::openmp::libomptarget::remote::RetrieveData* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::RetrieveData>(Arena*);
template<> ::openmp::libomptarget::remote::SubmitData* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::SubmitData>(Arena*);
template<> ::openmp::libomptarget::remote::TargetBinaryDescription* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::TargetBinaryDescription>(Arena*);
template<> ::openmp::libomptarget::remote::TargetDeviceImage* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::TargetDeviceImage>(Arena*);
template<> ::openmp::libomptarget::remote::TargetDeviceImagePtr* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::TargetDeviceImagePtr>(Arena*);
template<> ::openmp::libomptarget::remote::TargetOffloadEntry* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::TargetOffloadEntry>(Arena*);
template<> ::openmp::libomptarget::remote::TargetRegion* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::TargetRegion>(Arena*);
template<> ::openmp::libomptarget::remote::TargetTable* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::TargetTable>(Arena*);
template<> ::openmp::libomptarget::remote::TargetTeamRegion* Arena::CreateMaybeMessage<::openmp::libomptarget::remote::TargetTeamRegion>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openmp {
namespace libomptarget {
namespace remote {

// ===================================================================

class Null final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.Null) */ {
 public:
  inline Null() : Null(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Null(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Null(const Null& from);
  Null(Null&& from) noexcept
    : Null() {
    *this = ::std::move(from);
  }

  inline Null& operator=(const Null& from) {
    CopyFrom(from);
    return *this;
  }
  inline Null& operator=(Null&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Null& default_instance() {
    return *internal_default_instance();
  }
  static inline const Null* internal_default_instance() {
    return reinterpret_cast<const Null*>(
               &_Null_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Null& a, Null& b) {
    a.Swap(&b);
  }
  inline void Swap(Null* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Null* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Null* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Null>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Null& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Null& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.Null";
  }
  protected:
  explicit Null(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.Null)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class Pointer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.Pointer) */ {
 public:
  inline Pointer() : Pointer(nullptr) {}
  ~Pointer() override;
  explicit PROTOBUF_CONSTEXPR Pointer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pointer(const Pointer& from);
  Pointer(Pointer&& from) noexcept
    : Pointer() {
    *this = ::std::move(from);
  }

  inline Pointer& operator=(const Pointer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pointer& operator=(Pointer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pointer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pointer* internal_default_instance() {
    return reinterpret_cast<const Pointer*>(
               &_Pointer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Pointer& a, Pointer& b) {
    a.Swap(&b);
  }
  inline void Swap(Pointer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pointer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pointer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pointer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pointer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pointer& from) {
    Pointer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pointer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.Pointer";
  }
  protected:
  explicit Pointer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
  };
  // uint64 number = 1;
  void clear_number();
  uint64_t number() const;
  void set_number(uint64_t value);
  private:
  uint64_t _internal_number() const;
  void _internal_set_number(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.Pointer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class I32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.I32) */ {
 public:
  inline I32() : I32(nullptr) {}
  ~I32() override;
  explicit PROTOBUF_CONSTEXPR I32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  I32(const I32& from);
  I32(I32&& from) noexcept
    : I32() {
    *this = ::std::move(from);
  }

  inline I32& operator=(const I32& from) {
    CopyFrom(from);
    return *this;
  }
  inline I32& operator=(I32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const I32& default_instance() {
    return *internal_default_instance();
  }
  static inline const I32* internal_default_instance() {
    return reinterpret_cast<const I32*>(
               &_I32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(I32& a, I32& b) {
    a.Swap(&b);
  }
  inline void Swap(I32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(I32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  I32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<I32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const I32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const I32& from) {
    I32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(I32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.I32";
  }
  protected:
  explicit I32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
  };
  // int32 number = 1;
  void clear_number();
  int32_t number() const;
  void set_number(int32_t value);
  private:
  int32_t _internal_number() const;
  void _internal_set_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.I32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class I64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.I64) */ {
 public:
  inline I64() : I64(nullptr) {}
  ~I64() override;
  explicit PROTOBUF_CONSTEXPR I64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  I64(const I64& from);
  I64(I64&& from) noexcept
    : I64() {
    *this = ::std::move(from);
  }

  inline I64& operator=(const I64& from) {
    CopyFrom(from);
    return *this;
  }
  inline I64& operator=(I64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const I64& default_instance() {
    return *internal_default_instance();
  }
  static inline const I64* internal_default_instance() {
    return reinterpret_cast<const I64*>(
               &_I64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(I64& a, I64& b) {
    a.Swap(&b);
  }
  inline void Swap(I64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(I64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  I64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<I64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const I64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const I64& from) {
    I64::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(I64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.I64";
  }
  protected:
  explicit I64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
  };
  // int64 number = 1;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.I64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class DevicePair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.DevicePair) */ {
 public:
  inline DevicePair() : DevicePair(nullptr) {}
  ~DevicePair() override;
  explicit PROTOBUF_CONSTEXPR DevicePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicePair(const DevicePair& from);
  DevicePair(DevicePair&& from) noexcept
    : DevicePair() {
    *this = ::std::move(from);
  }

  inline DevicePair& operator=(const DevicePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicePair& operator=(DevicePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DevicePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicePair* internal_default_instance() {
    return reinterpret_cast<const DevicePair*>(
               &_DevicePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DevicePair& a, DevicePair& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicePair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DevicePair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DevicePair& from) {
    DevicePair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DevicePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.DevicePair";
  }
  protected:
  explicit DevicePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcDevIdFieldNumber = 1,
    kDstDevIdFieldNumber = 2,
  };
  // int32 src_dev_id = 1;
  void clear_src_dev_id();
  int32_t src_dev_id() const;
  void set_src_dev_id(int32_t value);
  private:
  int32_t _internal_src_dev_id() const;
  void _internal_set_src_dev_id(int32_t value);
  public:

  // int32 dst_dev_id = 2;
  void clear_dst_dev_id();
  int32_t dst_dev_id() const;
  void set_dst_dev_id(int32_t value);
  private:
  int32_t _internal_dst_dev_id() const;
  void _internal_set_dst_dev_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.DevicePair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t src_dev_id_;
    int32_t dst_dev_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class Binary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.Binary) */ {
 public:
  inline Binary() : Binary(nullptr) {}
  ~Binary() override;
  explicit PROTOBUF_CONSTEXPR Binary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Binary(const Binary& from);
  Binary(Binary&& from) noexcept
    : Binary() {
    *this = ::std::move(from);
  }

  inline Binary& operator=(const Binary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Binary& operator=(Binary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Binary& default_instance() {
    return *internal_default_instance();
  }
  static inline const Binary* internal_default_instance() {
    return reinterpret_cast<const Binary*>(
               &_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Binary& a, Binary& b) {
    a.Swap(&b);
  }
  inline void Swap(Binary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Binary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Binary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Binary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Binary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Binary& from) {
    Binary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.Binary";
  }
  protected:
  explicit Binary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagePtrFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
  };
  // uint64 image_ptr = 1;
  void clear_image_ptr();
  uint64_t image_ptr() const;
  void set_image_ptr(uint64_t value);
  private:
  uint64_t _internal_image_ptr() const;
  void _internal_set_image_ptr(uint64_t value);
  public:

  // int32 device_id = 2;
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.Binary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t image_ptr_;
    int32_t device_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class TargetOffloadEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.TargetOffloadEntry) */ {
 public:
  inline TargetOffloadEntry() : TargetOffloadEntry(nullptr) {}
  ~TargetOffloadEntry() override;
  explicit PROTOBUF_CONSTEXPR TargetOffloadEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetOffloadEntry(const TargetOffloadEntry& from);
  TargetOffloadEntry(TargetOffloadEntry&& from) noexcept
    : TargetOffloadEntry() {
    *this = ::std::move(from);
  }

  inline TargetOffloadEntry& operator=(const TargetOffloadEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetOffloadEntry& operator=(TargetOffloadEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetOffloadEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetOffloadEntry* internal_default_instance() {
    return reinterpret_cast<const TargetOffloadEntry*>(
               &_TargetOffloadEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TargetOffloadEntry& a, TargetOffloadEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetOffloadEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetOffloadEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetOffloadEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetOffloadEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetOffloadEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TargetOffloadEntry& from) {
    TargetOffloadEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetOffloadEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.TargetOffloadEntry";
  }
  protected:
  explicit TargetOffloadEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kNameFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kReservedFieldNumber = 4,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 flags = 3;
  void clear_flags();
  int32_t flags() const;
  void set_flags(int32_t value);
  private:
  int32_t _internal_flags() const;
  void _internal_set_flags(int32_t value);
  public:

  // int32 reserved = 4;
  void clear_reserved();
  int32_t reserved() const;
  void set_reserved(int32_t value);
  private:
  int32_t _internal_reserved() const;
  void _internal_set_reserved(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.TargetOffloadEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t flags_;
    int32_t reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class DeviceOffloadEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.DeviceOffloadEntry) */ {
 public:
  inline DeviceOffloadEntry() : DeviceOffloadEntry(nullptr) {}
  ~DeviceOffloadEntry() override;
  explicit PROTOBUF_CONSTEXPR DeviceOffloadEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceOffloadEntry(const DeviceOffloadEntry& from);
  DeviceOffloadEntry(DeviceOffloadEntry&& from) noexcept
    : DeviceOffloadEntry() {
    *this = ::std::move(from);
  }

  inline DeviceOffloadEntry& operator=(const DeviceOffloadEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceOffloadEntry& operator=(DeviceOffloadEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceOffloadEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceOffloadEntry* internal_default_instance() {
    return reinterpret_cast<const DeviceOffloadEntry*>(
               &_DeviceOffloadEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeviceOffloadEntry& a, DeviceOffloadEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceOffloadEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceOffloadEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceOffloadEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceOffloadEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceOffloadEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceOffloadEntry& from) {
    DeviceOffloadEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceOffloadEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.DeviceOffloadEntry";
  }
  protected:
  explicit DeviceOffloadEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kReservedFieldNumber = 4,
    kSizeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 addr = 2;
  void clear_addr();
  uint64_t addr() const;
  void set_addr(uint64_t value);
  private:
  uint64_t _internal_addr() const;
  void _internal_set_addr(uint64_t value);
  public:

  // int32 flags = 3;
  void clear_flags();
  int32_t flags() const;
  void set_flags(int32_t value);
  private:
  int32_t _internal_flags() const;
  void _internal_set_flags(int32_t value);
  public:

  // int32 reserved = 4;
  void clear_reserved();
  int32_t reserved() const;
  void set_reserved(int32_t value);
  private:
  int32_t _internal_reserved() const;
  void _internal_set_reserved(int32_t value);
  public:

  // int32 size = 5;
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.DeviceOffloadEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t addr_;
    int32_t flags_;
    int32_t reserved_;
    int32_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class TargetTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.TargetTable) */ {
 public:
  inline TargetTable() : TargetTable(nullptr) {}
  ~TargetTable() override;
  explicit PROTOBUF_CONSTEXPR TargetTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetTable(const TargetTable& from);
  TargetTable(TargetTable&& from) noexcept
    : TargetTable() {
    *this = ::std::move(from);
  }

  inline TargetTable& operator=(const TargetTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetTable& operator=(TargetTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetTable* internal_default_instance() {
    return reinterpret_cast<const TargetTable*>(
               &_TargetTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TargetTable& a, TargetTable& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TargetTable& from) {
    TargetTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.TargetTable";
  }
  protected:
  explicit TargetTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kEntryPtrsFieldNumber = 2,
  };
  // repeated .openmp.libomptarget.remote.DeviceOffloadEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::openmp::libomptarget::remote::DeviceOffloadEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::DeviceOffloadEntry >*
      mutable_entries();
  private:
  const ::openmp::libomptarget::remote::DeviceOffloadEntry& _internal_entries(int index) const;
  ::openmp::libomptarget::remote::DeviceOffloadEntry* _internal_add_entries();
  public:
  const ::openmp::libomptarget::remote::DeviceOffloadEntry& entries(int index) const;
  ::openmp::libomptarget::remote::DeviceOffloadEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::DeviceOffloadEntry >&
      entries() const;

  // repeated uint64 entry_ptrs = 2;
  int entry_ptrs_size() const;
  private:
  int _internal_entry_ptrs_size() const;
  public:
  void clear_entry_ptrs();
  private:
  uint64_t _internal_entry_ptrs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_entry_ptrs() const;
  void _internal_add_entry_ptrs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_entry_ptrs();
  public:
  uint64_t entry_ptrs(int index) const;
  void set_entry_ptrs(int index, uint64_t value);
  void add_entry_ptrs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      entry_ptrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_entry_ptrs();

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.TargetTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::DeviceOffloadEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > entry_ptrs_;
    mutable std::atomic<int> _entry_ptrs_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class TargetDeviceImagePtr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.TargetDeviceImagePtr) */ {
 public:
  inline TargetDeviceImagePtr() : TargetDeviceImagePtr(nullptr) {}
  ~TargetDeviceImagePtr() override;
  explicit PROTOBUF_CONSTEXPR TargetDeviceImagePtr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetDeviceImagePtr(const TargetDeviceImagePtr& from);
  TargetDeviceImagePtr(TargetDeviceImagePtr&& from) noexcept
    : TargetDeviceImagePtr() {
    *this = ::std::move(from);
  }

  inline TargetDeviceImagePtr& operator=(const TargetDeviceImagePtr& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetDeviceImagePtr& operator=(TargetDeviceImagePtr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetDeviceImagePtr& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetDeviceImagePtr* internal_default_instance() {
    return reinterpret_cast<const TargetDeviceImagePtr*>(
               &_TargetDeviceImagePtr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TargetDeviceImagePtr& a, TargetDeviceImagePtr& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetDeviceImagePtr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetDeviceImagePtr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetDeviceImagePtr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetDeviceImagePtr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetDeviceImagePtr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TargetDeviceImagePtr& from) {
    TargetDeviceImagePtr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetDeviceImagePtr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.TargetDeviceImagePtr";
  }
  protected:
  explicit TargetDeviceImagePtr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryPtrsFieldNumber = 2,
    kImagePtrFieldNumber = 1,
  };
  // repeated uint64 entry_ptrs = 2;
  int entry_ptrs_size() const;
  private:
  int _internal_entry_ptrs_size() const;
  public:
  void clear_entry_ptrs();
  private:
  uint64_t _internal_entry_ptrs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_entry_ptrs() const;
  void _internal_add_entry_ptrs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_entry_ptrs();
  public:
  uint64_t entry_ptrs(int index) const;
  void set_entry_ptrs(int index, uint64_t value);
  void add_entry_ptrs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      entry_ptrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_entry_ptrs();

  // uint64 image_ptr = 1;
  void clear_image_ptr();
  uint64_t image_ptr() const;
  void set_image_ptr(uint64_t value);
  private:
  uint64_t _internal_image_ptr() const;
  void _internal_set_image_ptr(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.TargetDeviceImagePtr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > entry_ptrs_;
    mutable std::atomic<int> _entry_ptrs_cached_byte_size_;
    uint64_t image_ptr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class TargetDeviceImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.TargetDeviceImage) */ {
 public:
  inline TargetDeviceImage() : TargetDeviceImage(nullptr) {}
  ~TargetDeviceImage() override;
  explicit PROTOBUF_CONSTEXPR TargetDeviceImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetDeviceImage(const TargetDeviceImage& from);
  TargetDeviceImage(TargetDeviceImage&& from) noexcept
    : TargetDeviceImage() {
    *this = ::std::move(from);
  }

  inline TargetDeviceImage& operator=(const TargetDeviceImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetDeviceImage& operator=(TargetDeviceImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetDeviceImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetDeviceImage* internal_default_instance() {
    return reinterpret_cast<const TargetDeviceImage*>(
               &_TargetDeviceImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TargetDeviceImage& a, TargetDeviceImage& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetDeviceImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetDeviceImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetDeviceImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetDeviceImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetDeviceImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TargetDeviceImage& from) {
    TargetDeviceImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetDeviceImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.TargetDeviceImage";
  }
  protected:
  explicit TargetDeviceImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 2,
    kBinaryFieldNumber = 1,
  };
  // repeated .openmp.libomptarget.remote.TargetOffloadEntry entries = 2;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::openmp::libomptarget::remote::TargetOffloadEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry >*
      mutable_entries();
  private:
  const ::openmp::libomptarget::remote::TargetOffloadEntry& _internal_entries(int index) const;
  ::openmp::libomptarget::remote::TargetOffloadEntry* _internal_add_entries();
  public:
  const ::openmp::libomptarget::remote::TargetOffloadEntry& entries(int index) const;
  ::openmp::libomptarget::remote::TargetOffloadEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry >&
      entries() const;

  // bytes binary = 1;
  void clear_binary();
  const std::string& binary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary();
  PROTOBUF_NODISCARD std::string* release_binary();
  void set_allocated_binary(std::string* binary);
  private:
  const std::string& _internal_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary(const std::string& value);
  std::string* _internal_mutable_binary();
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.TargetDeviceImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class ImagePtrs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.ImagePtrs) */ {
 public:
  inline ImagePtrs() : ImagePtrs(nullptr) {}
  ~ImagePtrs() override;
  explicit PROTOBUF_CONSTEXPR ImagePtrs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagePtrs(const ImagePtrs& from);
  ImagePtrs(ImagePtrs&& from) noexcept
    : ImagePtrs() {
    *this = ::std::move(from);
  }

  inline ImagePtrs& operator=(const ImagePtrs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagePtrs& operator=(ImagePtrs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagePtrs& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagePtrs* internal_default_instance() {
    return reinterpret_cast<const ImagePtrs*>(
               &_ImagePtrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ImagePtrs& a, ImagePtrs& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagePtrs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagePtrs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagePtrs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagePtrs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagePtrs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagePtrs& from) {
    ImagePtrs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagePtrs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.ImagePtrs";
  }
  protected:
  explicit ImagePtrs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryPtrsFieldNumber = 2,
    kImgPtrFieldNumber = 1,
  };
  // repeated uint64 entry_ptrs = 2;
  int entry_ptrs_size() const;
  private:
  int _internal_entry_ptrs_size() const;
  public:
  void clear_entry_ptrs();
  private:
  uint64_t _internal_entry_ptrs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_entry_ptrs() const;
  void _internal_add_entry_ptrs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_entry_ptrs();
  public:
  uint64_t entry_ptrs(int index) const;
  void set_entry_ptrs(int index, uint64_t value);
  void add_entry_ptrs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      entry_ptrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_entry_ptrs();

  // uint64 img_ptr = 1;
  void clear_img_ptr();
  uint64_t img_ptr() const;
  void set_img_ptr(uint64_t value);
  private:
  uint64_t _internal_img_ptr() const;
  void _internal_set_img_ptr(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.ImagePtrs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > entry_ptrs_;
    mutable std::atomic<int> _entry_ptrs_cached_byte_size_;
    uint64_t img_ptr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class TargetBinaryDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.TargetBinaryDescription) */ {
 public:
  inline TargetBinaryDescription() : TargetBinaryDescription(nullptr) {}
  ~TargetBinaryDescription() override;
  explicit PROTOBUF_CONSTEXPR TargetBinaryDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetBinaryDescription(const TargetBinaryDescription& from);
  TargetBinaryDescription(TargetBinaryDescription&& from) noexcept
    : TargetBinaryDescription() {
    *this = ::std::move(from);
  }

  inline TargetBinaryDescription& operator=(const TargetBinaryDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetBinaryDescription& operator=(TargetBinaryDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetBinaryDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetBinaryDescription* internal_default_instance() {
    return reinterpret_cast<const TargetBinaryDescription*>(
               &_TargetBinaryDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TargetBinaryDescription& a, TargetBinaryDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetBinaryDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetBinaryDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetBinaryDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetBinaryDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetBinaryDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TargetBinaryDescription& from) {
    TargetBinaryDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetBinaryDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.TargetBinaryDescription";
  }
  protected:
  explicit TargetBinaryDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagePtrsFieldNumber = 1,
    kEntriesFieldNumber = 2,
    kImagesFieldNumber = 3,
    kEntryPtrsFieldNumber = 4,
    kBinPtrFieldNumber = 5,
  };
  // repeated .openmp.libomptarget.remote.ImagePtrs image_ptrs = 1;
  int image_ptrs_size() const;
  private:
  int _internal_image_ptrs_size() const;
  public:
  void clear_image_ptrs();
  ::openmp::libomptarget::remote::ImagePtrs* mutable_image_ptrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::ImagePtrs >*
      mutable_image_ptrs();
  private:
  const ::openmp::libomptarget::remote::ImagePtrs& _internal_image_ptrs(int index) const;
  ::openmp::libomptarget::remote::ImagePtrs* _internal_add_image_ptrs();
  public:
  const ::openmp::libomptarget::remote::ImagePtrs& image_ptrs(int index) const;
  ::openmp::libomptarget::remote::ImagePtrs* add_image_ptrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::ImagePtrs >&
      image_ptrs() const;

  // repeated .openmp.libomptarget.remote.TargetOffloadEntry entries = 2;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::openmp::libomptarget::remote::TargetOffloadEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry >*
      mutable_entries();
  private:
  const ::openmp::libomptarget::remote::TargetOffloadEntry& _internal_entries(int index) const;
  ::openmp::libomptarget::remote::TargetOffloadEntry* _internal_add_entries();
  public:
  const ::openmp::libomptarget::remote::TargetOffloadEntry& entries(int index) const;
  ::openmp::libomptarget::remote::TargetOffloadEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry >&
      entries() const;

  // repeated .openmp.libomptarget.remote.TargetDeviceImage images = 3;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::openmp::libomptarget::remote::TargetDeviceImage* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetDeviceImage >*
      mutable_images();
  private:
  const ::openmp::libomptarget::remote::TargetDeviceImage& _internal_images(int index) const;
  ::openmp::libomptarget::remote::TargetDeviceImage* _internal_add_images();
  public:
  const ::openmp::libomptarget::remote::TargetDeviceImage& images(int index) const;
  ::openmp::libomptarget::remote::TargetDeviceImage* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetDeviceImage >&
      images() const;

  // repeated uint64 entry_ptrs = 4;
  int entry_ptrs_size() const;
  private:
  int _internal_entry_ptrs_size() const;
  public:
  void clear_entry_ptrs();
  private:
  uint64_t _internal_entry_ptrs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_entry_ptrs() const;
  void _internal_add_entry_ptrs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_entry_ptrs();
  public:
  uint64_t entry_ptrs(int index) const;
  void set_entry_ptrs(int index, uint64_t value);
  void add_entry_ptrs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      entry_ptrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_entry_ptrs();

  // uint64 bin_ptr = 5;
  void clear_bin_ptr();
  uint64_t bin_ptr() const;
  void set_bin_ptr(uint64_t value);
  private:
  uint64_t _internal_bin_ptr() const;
  void _internal_set_bin_ptr(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.TargetBinaryDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::ImagePtrs > image_ptrs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetDeviceImage > images_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > entry_ptrs_;
    mutable std::atomic<int> _entry_ptrs_cached_byte_size_;
    uint64_t bin_ptr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class AllocData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.AllocData) */ {
 public:
  inline AllocData() : AllocData(nullptr) {}
  ~AllocData() override;
  explicit PROTOBUF_CONSTEXPR AllocData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocData(const AllocData& from);
  AllocData(AllocData&& from) noexcept
    : AllocData() {
    *this = ::std::move(from);
  }

  inline AllocData& operator=(const AllocData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocData& operator=(AllocData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocData* internal_default_instance() {
    return reinterpret_cast<const AllocData*>(
               &_AllocData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AllocData& a, AllocData& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocData& from) {
    AllocData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.AllocData";
  }
  protected:
  explicit AllocData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
    kHstPtrFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
  };
  // uint64 size = 1;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // uint64 hst_ptr = 2;
  void clear_hst_ptr();
  uint64_t hst_ptr() const;
  void set_hst_ptr(uint64_t value);
  private:
  uint64_t _internal_hst_ptr() const;
  void _internal_set_hst_ptr(uint64_t value);
  public:

  // int32 device_id = 3;
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.AllocData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t size_;
    uint64_t hst_ptr_;
    int32_t device_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class SubmitData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.SubmitData) */ {
 public:
  inline SubmitData() : SubmitData(nullptr) {}
  ~SubmitData() override;
  explicit PROTOBUF_CONSTEXPR SubmitData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitData(const SubmitData& from);
  SubmitData(SubmitData&& from) noexcept
    : SubmitData() {
    *this = ::std::move(from);
  }

  inline SubmitData& operator=(const SubmitData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitData& operator=(SubmitData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitData* internal_default_instance() {
    return reinterpret_cast<const SubmitData*>(
               &_SubmitData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SubmitData& a, SubmitData& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitData& from) {
    SubmitData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.SubmitData";
  }
  protected:
  explicit SubmitData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kHstPtrFieldNumber = 2,
    kTgtPtrFieldNumber = 3,
    kStartFieldNumber = 5,
    kSizeFieldNumber = 6,
    kDeviceIdFieldNumber = 7,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 hst_ptr = 2;
  void clear_hst_ptr();
  uint64_t hst_ptr() const;
  void set_hst_ptr(uint64_t value);
  private:
  uint64_t _internal_hst_ptr() const;
  void _internal_set_hst_ptr(uint64_t value);
  public:

  // uint64 tgt_ptr = 3;
  void clear_tgt_ptr();
  uint64_t tgt_ptr() const;
  void set_tgt_ptr(uint64_t value);
  private:
  uint64_t _internal_tgt_ptr() const;
  void _internal_set_tgt_ptr(uint64_t value);
  public:

  // uint64 start = 5;
  void clear_start();
  uint64_t start() const;
  void set_start(uint64_t value);
  private:
  uint64_t _internal_start() const;
  void _internal_set_start(uint64_t value);
  public:

  // uint64 size = 6;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // int32 device_id = 7;
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.SubmitData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t hst_ptr_;
    uint64_t tgt_ptr_;
    uint64_t start_;
    uint64_t size_;
    int32_t device_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class RetrieveData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.RetrieveData) */ {
 public:
  inline RetrieveData() : RetrieveData(nullptr) {}
  ~RetrieveData() override;
  explicit PROTOBUF_CONSTEXPR RetrieveData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RetrieveData(const RetrieveData& from);
  RetrieveData(RetrieveData&& from) noexcept
    : RetrieveData() {
    *this = ::std::move(from);
  }

  inline RetrieveData& operator=(const RetrieveData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetrieveData& operator=(RetrieveData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RetrieveData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RetrieveData* internal_default_instance() {
    return reinterpret_cast<const RetrieveData*>(
               &_RetrieveData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RetrieveData& a, RetrieveData& b) {
    a.Swap(&b);
  }
  inline void Swap(RetrieveData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetrieveData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RetrieveData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RetrieveData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RetrieveData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RetrieveData& from) {
    RetrieveData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetrieveData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.RetrieveData";
  }
  protected:
  explicit RetrieveData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHstPtrFieldNumber = 1,
    kTgtPtrFieldNumber = 2,
    kSizeFieldNumber = 3,
    kDeviceIdFieldNumber = 5,
  };
  // uint64 hst_ptr = 1;
  void clear_hst_ptr();
  uint64_t hst_ptr() const;
  void set_hst_ptr(uint64_t value);
  private:
  uint64_t _internal_hst_ptr() const;
  void _internal_set_hst_ptr(uint64_t value);
  public:

  // uint64 tgt_ptr = 2;
  void clear_tgt_ptr();
  uint64_t tgt_ptr() const;
  void set_tgt_ptr(uint64_t value);
  private:
  uint64_t _internal_tgt_ptr() const;
  void _internal_set_tgt_ptr(uint64_t value);
  public:

  // uint64 size = 3;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // int32 device_id = 5;
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.RetrieveData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hst_ptr_;
    uint64_t tgt_ptr_;
    uint64_t size_;
    int32_t device_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit PROTOBUF_CONSTEXPR Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Data& from) {
    Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kStartFieldNumber = 2,
    kSizeFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 start = 2;
  void clear_start();
  uint64_t start() const;
  void set_start(uint64_t value);
  private:
  uint64_t _internal_start() const;
  void _internal_set_start(uint64_t value);
  public:

  // uint64 size = 3;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // int32 ret = 4;
  void clear_ret();
  int32_t ret() const;
  void set_ret(int32_t value);
  private:
  int32_t _internal_ret() const;
  void _internal_set_ret(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t start_;
    uint64_t size_;
    int32_t ret_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class ExchangeData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.ExchangeData) */ {
 public:
  inline ExchangeData() : ExchangeData(nullptr) {}
  ~ExchangeData() override;
  explicit PROTOBUF_CONSTEXPR ExchangeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeData(const ExchangeData& from);
  ExchangeData(ExchangeData&& from) noexcept
    : ExchangeData() {
    *this = ::std::move(from);
  }

  inline ExchangeData& operator=(const ExchangeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeData& operator=(ExchangeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeData* internal_default_instance() {
    return reinterpret_cast<const ExchangeData*>(
               &_ExchangeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ExchangeData& a, ExchangeData& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExchangeData& from) {
    ExchangeData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.ExchangeData";
  }
  protected:
  explicit ExchangeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcDevIdFieldNumber = 1,
    kSrcPtrFieldNumber = 2,
    kDstDevIdFieldNumber = 3,
    kDstPtrFieldNumber = 4,
    kSizeFieldNumber = 6,
  };
  // uint64 src_dev_id = 1;
  void clear_src_dev_id();
  uint64_t src_dev_id() const;
  void set_src_dev_id(uint64_t value);
  private:
  uint64_t _internal_src_dev_id() const;
  void _internal_set_src_dev_id(uint64_t value);
  public:

  // uint64 src_ptr = 2;
  void clear_src_ptr();
  uint64_t src_ptr() const;
  void set_src_ptr(uint64_t value);
  private:
  uint64_t _internal_src_ptr() const;
  void _internal_set_src_ptr(uint64_t value);
  public:

  // uint64 dst_dev_id = 3;
  void clear_dst_dev_id();
  uint64_t dst_dev_id() const;
  void set_dst_dev_id(uint64_t value);
  private:
  uint64_t _internal_dst_dev_id() const;
  void _internal_set_dst_dev_id(uint64_t value);
  public:

  // uint64 dst_ptr = 4;
  void clear_dst_ptr();
  uint64_t dst_ptr() const;
  void set_dst_ptr(uint64_t value);
  private:
  uint64_t _internal_dst_ptr() const;
  void _internal_set_dst_ptr(uint64_t value);
  public:

  // uint64 size = 6;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.ExchangeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t src_dev_id_;
    uint64_t src_ptr_;
    uint64_t dst_dev_id_;
    uint64_t dst_ptr_;
    uint64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class DeleteData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.DeleteData) */ {
 public:
  inline DeleteData() : DeleteData(nullptr) {}
  ~DeleteData() override;
  explicit PROTOBUF_CONSTEXPR DeleteData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteData(const DeleteData& from);
  DeleteData(DeleteData&& from) noexcept
    : DeleteData() {
    *this = ::std::move(from);
  }

  inline DeleteData& operator=(const DeleteData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteData& operator=(DeleteData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteData* internal_default_instance() {
    return reinterpret_cast<const DeleteData*>(
               &_DeleteData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteData& a, DeleteData& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteData& from) {
    DeleteData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.DeleteData";
  }
  protected:
  explicit DeleteData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTgtPtrFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
  };
  // uint64 tgt_ptr = 1;
  void clear_tgt_ptr();
  uint64_t tgt_ptr() const;
  void set_tgt_ptr(uint64_t value);
  private:
  uint64_t _internal_tgt_ptr() const;
  void _internal_set_tgt_ptr(uint64_t value);
  public:

  // int32 device_id = 2;
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.DeleteData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t tgt_ptr_;
    int32_t device_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class TargetRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.TargetRegion) */ {
 public:
  inline TargetRegion() : TargetRegion(nullptr) {}
  ~TargetRegion() override;
  explicit PROTOBUF_CONSTEXPR TargetRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetRegion(const TargetRegion& from);
  TargetRegion(TargetRegion&& from) noexcept
    : TargetRegion() {
    *this = ::std::move(from);
  }

  inline TargetRegion& operator=(const TargetRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetRegion& operator=(TargetRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetRegion* internal_default_instance() {
    return reinterpret_cast<const TargetRegion*>(
               &_TargetRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TargetRegion& a, TargetRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetRegion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TargetRegion& from) {
    TargetRegion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetRegion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.TargetRegion";
  }
  protected:
  explicit TargetRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTgtArgsFieldNumber = 1,
    kTgtOffsetsFieldNumber = 2,
    kTgtEntryPtrFieldNumber = 3,
    kDeviceIdFieldNumber = 4,
    kArgNumFieldNumber = 5,
  };
  // repeated uint64 tgt_args = 1;
  int tgt_args_size() const;
  private:
  int _internal_tgt_args_size() const;
  public:
  void clear_tgt_args();
  private:
  uint64_t _internal_tgt_args(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_tgt_args() const;
  void _internal_add_tgt_args(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_tgt_args();
  public:
  uint64_t tgt_args(int index) const;
  void set_tgt_args(int index, uint64_t value);
  void add_tgt_args(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      tgt_args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_tgt_args();

  // repeated int64 tgt_offsets = 2;
  int tgt_offsets_size() const;
  private:
  int _internal_tgt_offsets_size() const;
  public:
  void clear_tgt_offsets();
  private:
  int64_t _internal_tgt_offsets(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_tgt_offsets() const;
  void _internal_add_tgt_offsets(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_tgt_offsets();
  public:
  int64_t tgt_offsets(int index) const;
  void set_tgt_offsets(int index, int64_t value);
  void add_tgt_offsets(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      tgt_offsets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_tgt_offsets();

  // uint64 tgt_entry_ptr = 3;
  void clear_tgt_entry_ptr();
  uint64_t tgt_entry_ptr() const;
  void set_tgt_entry_ptr(uint64_t value);
  private:
  uint64_t _internal_tgt_entry_ptr() const;
  void _internal_set_tgt_entry_ptr(uint64_t value);
  public:

  // int32 device_id = 4;
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // int32 arg_num = 5;
  void clear_arg_num();
  int32_t arg_num() const;
  void set_arg_num(int32_t value);
  private:
  int32_t _internal_arg_num() const;
  void _internal_set_arg_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.TargetRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > tgt_args_;
    mutable std::atomic<int> _tgt_args_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > tgt_offsets_;
    mutable std::atomic<int> _tgt_offsets_cached_byte_size_;
    uint64_t tgt_entry_ptr_;
    int32_t device_id_;
    int32_t arg_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// -------------------------------------------------------------------

class TargetTeamRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openmp.libomptarget.remote.TargetTeamRegion) */ {
 public:
  inline TargetTeamRegion() : TargetTeamRegion(nullptr) {}
  ~TargetTeamRegion() override;
  explicit PROTOBUF_CONSTEXPR TargetTeamRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetTeamRegion(const TargetTeamRegion& from);
  TargetTeamRegion(TargetTeamRegion&& from) noexcept
    : TargetTeamRegion() {
    *this = ::std::move(from);
  }

  inline TargetTeamRegion& operator=(const TargetTeamRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetTeamRegion& operator=(TargetTeamRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetTeamRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetTeamRegion* internal_default_instance() {
    return reinterpret_cast<const TargetTeamRegion*>(
               &_TargetTeamRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TargetTeamRegion& a, TargetTeamRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetTeamRegion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetTeamRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetTeamRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetTeamRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetTeamRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TargetTeamRegion& from) {
    TargetTeamRegion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetTeamRegion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openmp.libomptarget.remote.TargetTeamRegion";
  }
  protected:
  explicit TargetTeamRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTgtArgsFieldNumber = 1,
    kTgtOffsetsFieldNumber = 2,
    kTgtEntryPtrFieldNumber = 3,
    kLoopTripcountFieldNumber = 4,
    kDeviceIdFieldNumber = 5,
    kArgNumFieldNumber = 6,
    kTeamNumFieldNumber = 7,
    kThreadLimitFieldNumber = 8,
  };
  // repeated uint64 tgt_args = 1;
  int tgt_args_size() const;
  private:
  int _internal_tgt_args_size() const;
  public:
  void clear_tgt_args();
  private:
  uint64_t _internal_tgt_args(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_tgt_args() const;
  void _internal_add_tgt_args(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_tgt_args();
  public:
  uint64_t tgt_args(int index) const;
  void set_tgt_args(int index, uint64_t value);
  void add_tgt_args(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      tgt_args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_tgt_args();

  // repeated int64 tgt_offsets = 2;
  int tgt_offsets_size() const;
  private:
  int _internal_tgt_offsets_size() const;
  public:
  void clear_tgt_offsets();
  private:
  int64_t _internal_tgt_offsets(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_tgt_offsets() const;
  void _internal_add_tgt_offsets(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_tgt_offsets();
  public:
  int64_t tgt_offsets(int index) const;
  void set_tgt_offsets(int index, int64_t value);
  void add_tgt_offsets(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      tgt_offsets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_tgt_offsets();

  // uint64 tgt_entry_ptr = 3;
  void clear_tgt_entry_ptr();
  uint64_t tgt_entry_ptr() const;
  void set_tgt_entry_ptr(uint64_t value);
  private:
  uint64_t _internal_tgt_entry_ptr() const;
  void _internal_set_tgt_entry_ptr(uint64_t value);
  public:

  // uint64 loop_tripcount = 4;
  void clear_loop_tripcount();
  uint64_t loop_tripcount() const;
  void set_loop_tripcount(uint64_t value);
  private:
  uint64_t _internal_loop_tripcount() const;
  void _internal_set_loop_tripcount(uint64_t value);
  public:

  // int32 device_id = 5;
  void clear_device_id();
  int32_t device_id() const;
  void set_device_id(int32_t value);
  private:
  int32_t _internal_device_id() const;
  void _internal_set_device_id(int32_t value);
  public:

  // int32 arg_num = 6;
  void clear_arg_num();
  int32_t arg_num() const;
  void set_arg_num(int32_t value);
  private:
  int32_t _internal_arg_num() const;
  void _internal_set_arg_num(int32_t value);
  public:

  // int32 team_num = 7;
  void clear_team_num();
  int32_t team_num() const;
  void set_team_num(int32_t value);
  private:
  int32_t _internal_team_num() const;
  void _internal_set_team_num(int32_t value);
  public:

  // int32 thread_limit = 8;
  void clear_thread_limit();
  int32_t thread_limit() const;
  void set_thread_limit(int32_t value);
  private:
  int32_t _internal_thread_limit() const;
  void _internal_set_thread_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openmp.libomptarget.remote.TargetTeamRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > tgt_args_;
    mutable std::atomic<int> _tgt_args_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > tgt_offsets_;
    mutable std::atomic<int> _tgt_offsets_cached_byte_size_;
    uint64_t tgt_entry_ptr_;
    uint64_t loop_tripcount_;
    int32_t device_id_;
    int32_t arg_num_;
    int32_t team_num_;
    int32_t thread_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openmp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Null

// -------------------------------------------------------------------

// Pointer

// uint64 number = 1;
inline void Pointer::clear_number() {
  _impl_.number_ = uint64_t{0u};
}
inline uint64_t Pointer::_internal_number() const {
  return _impl_.number_;
}
inline uint64_t Pointer::number() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.Pointer.number)
  return _internal_number();
}
inline void Pointer::_internal_set_number(uint64_t value) {
  
  _impl_.number_ = value;
}
inline void Pointer::set_number(uint64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.Pointer.number)
}

// -------------------------------------------------------------------

// I32

// int32 number = 1;
inline void I32::clear_number() {
  _impl_.number_ = 0;
}
inline int32_t I32::_internal_number() const {
  return _impl_.number_;
}
inline int32_t I32::number() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.I32.number)
  return _internal_number();
}
inline void I32::_internal_set_number(int32_t value) {
  
  _impl_.number_ = value;
}
inline void I32::set_number(int32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.I32.number)
}

// -------------------------------------------------------------------

// I64

// int64 number = 1;
inline void I64::clear_number() {
  _impl_.number_ = int64_t{0};
}
inline int64_t I64::_internal_number() const {
  return _impl_.number_;
}
inline int64_t I64::number() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.I64.number)
  return _internal_number();
}
inline void I64::_internal_set_number(int64_t value) {
  
  _impl_.number_ = value;
}
inline void I64::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.I64.number)
}

// -------------------------------------------------------------------

// DevicePair

// int32 src_dev_id = 1;
inline void DevicePair::clear_src_dev_id() {
  _impl_.src_dev_id_ = 0;
}
inline int32_t DevicePair::_internal_src_dev_id() const {
  return _impl_.src_dev_id_;
}
inline int32_t DevicePair::src_dev_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DevicePair.src_dev_id)
  return _internal_src_dev_id();
}
inline void DevicePair::_internal_set_src_dev_id(int32_t value) {
  
  _impl_.src_dev_id_ = value;
}
inline void DevicePair::set_src_dev_id(int32_t value) {
  _internal_set_src_dev_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DevicePair.src_dev_id)
}

// int32 dst_dev_id = 2;
inline void DevicePair::clear_dst_dev_id() {
  _impl_.dst_dev_id_ = 0;
}
inline int32_t DevicePair::_internal_dst_dev_id() const {
  return _impl_.dst_dev_id_;
}
inline int32_t DevicePair::dst_dev_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DevicePair.dst_dev_id)
  return _internal_dst_dev_id();
}
inline void DevicePair::_internal_set_dst_dev_id(int32_t value) {
  
  _impl_.dst_dev_id_ = value;
}
inline void DevicePair::set_dst_dev_id(int32_t value) {
  _internal_set_dst_dev_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DevicePair.dst_dev_id)
}

// -------------------------------------------------------------------

// Binary

// uint64 image_ptr = 1;
inline void Binary::clear_image_ptr() {
  _impl_.image_ptr_ = uint64_t{0u};
}
inline uint64_t Binary::_internal_image_ptr() const {
  return _impl_.image_ptr_;
}
inline uint64_t Binary::image_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.Binary.image_ptr)
  return _internal_image_ptr();
}
inline void Binary::_internal_set_image_ptr(uint64_t value) {
  
  _impl_.image_ptr_ = value;
}
inline void Binary::set_image_ptr(uint64_t value) {
  _internal_set_image_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.Binary.image_ptr)
}

// int32 device_id = 2;
inline void Binary::clear_device_id() {
  _impl_.device_id_ = 0;
}
inline int32_t Binary::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t Binary::device_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.Binary.device_id)
  return _internal_device_id();
}
inline void Binary::_internal_set_device_id(int32_t value) {
  
  _impl_.device_id_ = value;
}
inline void Binary::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.Binary.device_id)
}

// -------------------------------------------------------------------

// TargetOffloadEntry

// bytes data = 1;
inline void TargetOffloadEntry::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TargetOffloadEntry::data() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetOffloadEntry.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetOffloadEntry::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetOffloadEntry.data)
}
inline std::string* TargetOffloadEntry::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.TargetOffloadEntry.data)
  return _s;
}
inline const std::string& TargetOffloadEntry::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TargetOffloadEntry::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TargetOffloadEntry::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TargetOffloadEntry::release_data() {
  // @@protoc_insertion_point(field_release:openmp.libomptarget.remote.TargetOffloadEntry.data)
  return _impl_.data_.Release();
}
inline void TargetOffloadEntry::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmp.libomptarget.remote.TargetOffloadEntry.data)
}

// string name = 2;
inline void TargetOffloadEntry::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TargetOffloadEntry::name() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetOffloadEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetOffloadEntry::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetOffloadEntry.name)
}
inline std::string* TargetOffloadEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.TargetOffloadEntry.name)
  return _s;
}
inline const std::string& TargetOffloadEntry::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TargetOffloadEntry::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TargetOffloadEntry::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TargetOffloadEntry::release_name() {
  // @@protoc_insertion_point(field_release:openmp.libomptarget.remote.TargetOffloadEntry.name)
  return _impl_.name_.Release();
}
inline void TargetOffloadEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmp.libomptarget.remote.TargetOffloadEntry.name)
}

// int32 flags = 3;
inline void TargetOffloadEntry::clear_flags() {
  _impl_.flags_ = 0;
}
inline int32_t TargetOffloadEntry::_internal_flags() const {
  return _impl_.flags_;
}
inline int32_t TargetOffloadEntry::flags() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetOffloadEntry.flags)
  return _internal_flags();
}
inline void TargetOffloadEntry::_internal_set_flags(int32_t value) {
  
  _impl_.flags_ = value;
}
inline void TargetOffloadEntry::set_flags(int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetOffloadEntry.flags)
}

// int32 reserved = 4;
inline void TargetOffloadEntry::clear_reserved() {
  _impl_.reserved_ = 0;
}
inline int32_t TargetOffloadEntry::_internal_reserved() const {
  return _impl_.reserved_;
}
inline int32_t TargetOffloadEntry::reserved() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetOffloadEntry.reserved)
  return _internal_reserved();
}
inline void TargetOffloadEntry::_internal_set_reserved(int32_t value) {
  
  _impl_.reserved_ = value;
}
inline void TargetOffloadEntry::set_reserved(int32_t value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetOffloadEntry.reserved)
}

// -------------------------------------------------------------------

// DeviceOffloadEntry

// string name = 1;
inline void DeviceOffloadEntry::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeviceOffloadEntry::name() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DeviceOffloadEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceOffloadEntry::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DeviceOffloadEntry.name)
}
inline std::string* DeviceOffloadEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.DeviceOffloadEntry.name)
  return _s;
}
inline const std::string& DeviceOffloadEntry::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeviceOffloadEntry::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceOffloadEntry::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceOffloadEntry::release_name() {
  // @@protoc_insertion_point(field_release:openmp.libomptarget.remote.DeviceOffloadEntry.name)
  return _impl_.name_.Release();
}
inline void DeviceOffloadEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmp.libomptarget.remote.DeviceOffloadEntry.name)
}

// uint64 addr = 2;
inline void DeviceOffloadEntry::clear_addr() {
  _impl_.addr_ = uint64_t{0u};
}
inline uint64_t DeviceOffloadEntry::_internal_addr() const {
  return _impl_.addr_;
}
inline uint64_t DeviceOffloadEntry::addr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DeviceOffloadEntry.addr)
  return _internal_addr();
}
inline void DeviceOffloadEntry::_internal_set_addr(uint64_t value) {
  
  _impl_.addr_ = value;
}
inline void DeviceOffloadEntry::set_addr(uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DeviceOffloadEntry.addr)
}

// int32 flags = 3;
inline void DeviceOffloadEntry::clear_flags() {
  _impl_.flags_ = 0;
}
inline int32_t DeviceOffloadEntry::_internal_flags() const {
  return _impl_.flags_;
}
inline int32_t DeviceOffloadEntry::flags() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DeviceOffloadEntry.flags)
  return _internal_flags();
}
inline void DeviceOffloadEntry::_internal_set_flags(int32_t value) {
  
  _impl_.flags_ = value;
}
inline void DeviceOffloadEntry::set_flags(int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DeviceOffloadEntry.flags)
}

// int32 reserved = 4;
inline void DeviceOffloadEntry::clear_reserved() {
  _impl_.reserved_ = 0;
}
inline int32_t DeviceOffloadEntry::_internal_reserved() const {
  return _impl_.reserved_;
}
inline int32_t DeviceOffloadEntry::reserved() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DeviceOffloadEntry.reserved)
  return _internal_reserved();
}
inline void DeviceOffloadEntry::_internal_set_reserved(int32_t value) {
  
  _impl_.reserved_ = value;
}
inline void DeviceOffloadEntry::set_reserved(int32_t value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DeviceOffloadEntry.reserved)
}

// int32 size = 5;
inline void DeviceOffloadEntry::clear_size() {
  _impl_.size_ = 0;
}
inline int32_t DeviceOffloadEntry::_internal_size() const {
  return _impl_.size_;
}
inline int32_t DeviceOffloadEntry::size() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DeviceOffloadEntry.size)
  return _internal_size();
}
inline void DeviceOffloadEntry::_internal_set_size(int32_t value) {
  
  _impl_.size_ = value;
}
inline void DeviceOffloadEntry::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DeviceOffloadEntry.size)
}

// -------------------------------------------------------------------

// TargetTable

// repeated .openmp.libomptarget.remote.DeviceOffloadEntry entries = 1;
inline int TargetTable::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int TargetTable::entries_size() const {
  return _internal_entries_size();
}
inline void TargetTable::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::openmp::libomptarget::remote::DeviceOffloadEntry* TargetTable::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.TargetTable.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::DeviceOffloadEntry >*
TargetTable::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetTable.entries)
  return &_impl_.entries_;
}
inline const ::openmp::libomptarget::remote::DeviceOffloadEntry& TargetTable::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::openmp::libomptarget::remote::DeviceOffloadEntry& TargetTable::entries(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTable.entries)
  return _internal_entries(index);
}
inline ::openmp::libomptarget::remote::DeviceOffloadEntry* TargetTable::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::openmp::libomptarget::remote::DeviceOffloadEntry* TargetTable::add_entries() {
  ::openmp::libomptarget::remote::DeviceOffloadEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetTable.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::DeviceOffloadEntry >&
TargetTable::entries() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetTable.entries)
  return _impl_.entries_;
}

// repeated uint64 entry_ptrs = 2;
inline int TargetTable::_internal_entry_ptrs_size() const {
  return _impl_.entry_ptrs_.size();
}
inline int TargetTable::entry_ptrs_size() const {
  return _internal_entry_ptrs_size();
}
inline void TargetTable::clear_entry_ptrs() {
  _impl_.entry_ptrs_.Clear();
}
inline uint64_t TargetTable::_internal_entry_ptrs(int index) const {
  return _impl_.entry_ptrs_.Get(index);
}
inline uint64_t TargetTable::entry_ptrs(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTable.entry_ptrs)
  return _internal_entry_ptrs(index);
}
inline void TargetTable::set_entry_ptrs(int index, uint64_t value) {
  _impl_.entry_ptrs_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTable.entry_ptrs)
}
inline void TargetTable::_internal_add_entry_ptrs(uint64_t value) {
  _impl_.entry_ptrs_.Add(value);
}
inline void TargetTable::add_entry_ptrs(uint64_t value) {
  _internal_add_entry_ptrs(value);
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetTable.entry_ptrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetTable::_internal_entry_ptrs() const {
  return _impl_.entry_ptrs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetTable::entry_ptrs() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetTable.entry_ptrs)
  return _internal_entry_ptrs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetTable::_internal_mutable_entry_ptrs() {
  return &_impl_.entry_ptrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetTable::mutable_entry_ptrs() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetTable.entry_ptrs)
  return _internal_mutable_entry_ptrs();
}

// -------------------------------------------------------------------

// TargetDeviceImagePtr

// uint64 image_ptr = 1;
inline void TargetDeviceImagePtr::clear_image_ptr() {
  _impl_.image_ptr_ = uint64_t{0u};
}
inline uint64_t TargetDeviceImagePtr::_internal_image_ptr() const {
  return _impl_.image_ptr_;
}
inline uint64_t TargetDeviceImagePtr::image_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetDeviceImagePtr.image_ptr)
  return _internal_image_ptr();
}
inline void TargetDeviceImagePtr::_internal_set_image_ptr(uint64_t value) {
  
  _impl_.image_ptr_ = value;
}
inline void TargetDeviceImagePtr::set_image_ptr(uint64_t value) {
  _internal_set_image_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetDeviceImagePtr.image_ptr)
}

// repeated uint64 entry_ptrs = 2;
inline int TargetDeviceImagePtr::_internal_entry_ptrs_size() const {
  return _impl_.entry_ptrs_.size();
}
inline int TargetDeviceImagePtr::entry_ptrs_size() const {
  return _internal_entry_ptrs_size();
}
inline void TargetDeviceImagePtr::clear_entry_ptrs() {
  _impl_.entry_ptrs_.Clear();
}
inline uint64_t TargetDeviceImagePtr::_internal_entry_ptrs(int index) const {
  return _impl_.entry_ptrs_.Get(index);
}
inline uint64_t TargetDeviceImagePtr::entry_ptrs(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetDeviceImagePtr.entry_ptrs)
  return _internal_entry_ptrs(index);
}
inline void TargetDeviceImagePtr::set_entry_ptrs(int index, uint64_t value) {
  _impl_.entry_ptrs_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetDeviceImagePtr.entry_ptrs)
}
inline void TargetDeviceImagePtr::_internal_add_entry_ptrs(uint64_t value) {
  _impl_.entry_ptrs_.Add(value);
}
inline void TargetDeviceImagePtr::add_entry_ptrs(uint64_t value) {
  _internal_add_entry_ptrs(value);
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetDeviceImagePtr.entry_ptrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetDeviceImagePtr::_internal_entry_ptrs() const {
  return _impl_.entry_ptrs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetDeviceImagePtr::entry_ptrs() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetDeviceImagePtr.entry_ptrs)
  return _internal_entry_ptrs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetDeviceImagePtr::_internal_mutable_entry_ptrs() {
  return &_impl_.entry_ptrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetDeviceImagePtr::mutable_entry_ptrs() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetDeviceImagePtr.entry_ptrs)
  return _internal_mutable_entry_ptrs();
}

// -------------------------------------------------------------------

// TargetDeviceImage

// bytes binary = 1;
inline void TargetDeviceImage::clear_binary() {
  _impl_.binary_.ClearToEmpty();
}
inline const std::string& TargetDeviceImage::binary() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetDeviceImage.binary)
  return _internal_binary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetDeviceImage::set_binary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.binary_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetDeviceImage.binary)
}
inline std::string* TargetDeviceImage::mutable_binary() {
  std::string* _s = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.TargetDeviceImage.binary)
  return _s;
}
inline const std::string& TargetDeviceImage::_internal_binary() const {
  return _impl_.binary_.Get();
}
inline void TargetDeviceImage::_internal_set_binary(const std::string& value) {
  
  _impl_.binary_.Set(value, GetArenaForAllocation());
}
inline std::string* TargetDeviceImage::_internal_mutable_binary() {
  
  return _impl_.binary_.Mutable(GetArenaForAllocation());
}
inline std::string* TargetDeviceImage::release_binary() {
  // @@protoc_insertion_point(field_release:openmp.libomptarget.remote.TargetDeviceImage.binary)
  return _impl_.binary_.Release();
}
inline void TargetDeviceImage::set_allocated_binary(std::string* binary) {
  if (binary != nullptr) {
    
  } else {
    
  }
  _impl_.binary_.SetAllocated(binary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binary_.IsDefault()) {
    _impl_.binary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmp.libomptarget.remote.TargetDeviceImage.binary)
}

// repeated .openmp.libomptarget.remote.TargetOffloadEntry entries = 2;
inline int TargetDeviceImage::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int TargetDeviceImage::entries_size() const {
  return _internal_entries_size();
}
inline void TargetDeviceImage::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::openmp::libomptarget::remote::TargetOffloadEntry* TargetDeviceImage::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.TargetDeviceImage.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry >*
TargetDeviceImage::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetDeviceImage.entries)
  return &_impl_.entries_;
}
inline const ::openmp::libomptarget::remote::TargetOffloadEntry& TargetDeviceImage::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::openmp::libomptarget::remote::TargetOffloadEntry& TargetDeviceImage::entries(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetDeviceImage.entries)
  return _internal_entries(index);
}
inline ::openmp::libomptarget::remote::TargetOffloadEntry* TargetDeviceImage::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::openmp::libomptarget::remote::TargetOffloadEntry* TargetDeviceImage::add_entries() {
  ::openmp::libomptarget::remote::TargetOffloadEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetDeviceImage.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry >&
TargetDeviceImage::entries() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetDeviceImage.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// ImagePtrs

// uint64 img_ptr = 1;
inline void ImagePtrs::clear_img_ptr() {
  _impl_.img_ptr_ = uint64_t{0u};
}
inline uint64_t ImagePtrs::_internal_img_ptr() const {
  return _impl_.img_ptr_;
}
inline uint64_t ImagePtrs::img_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.ImagePtrs.img_ptr)
  return _internal_img_ptr();
}
inline void ImagePtrs::_internal_set_img_ptr(uint64_t value) {
  
  _impl_.img_ptr_ = value;
}
inline void ImagePtrs::set_img_ptr(uint64_t value) {
  _internal_set_img_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.ImagePtrs.img_ptr)
}

// repeated uint64 entry_ptrs = 2;
inline int ImagePtrs::_internal_entry_ptrs_size() const {
  return _impl_.entry_ptrs_.size();
}
inline int ImagePtrs::entry_ptrs_size() const {
  return _internal_entry_ptrs_size();
}
inline void ImagePtrs::clear_entry_ptrs() {
  _impl_.entry_ptrs_.Clear();
}
inline uint64_t ImagePtrs::_internal_entry_ptrs(int index) const {
  return _impl_.entry_ptrs_.Get(index);
}
inline uint64_t ImagePtrs::entry_ptrs(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.ImagePtrs.entry_ptrs)
  return _internal_entry_ptrs(index);
}
inline void ImagePtrs::set_entry_ptrs(int index, uint64_t value) {
  _impl_.entry_ptrs_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.ImagePtrs.entry_ptrs)
}
inline void ImagePtrs::_internal_add_entry_ptrs(uint64_t value) {
  _impl_.entry_ptrs_.Add(value);
}
inline void ImagePtrs::add_entry_ptrs(uint64_t value) {
  _internal_add_entry_ptrs(value);
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.ImagePtrs.entry_ptrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ImagePtrs::_internal_entry_ptrs() const {
  return _impl_.entry_ptrs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ImagePtrs::entry_ptrs() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.ImagePtrs.entry_ptrs)
  return _internal_entry_ptrs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ImagePtrs::_internal_mutable_entry_ptrs() {
  return &_impl_.entry_ptrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ImagePtrs::mutable_entry_ptrs() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.ImagePtrs.entry_ptrs)
  return _internal_mutable_entry_ptrs();
}

// -------------------------------------------------------------------

// TargetBinaryDescription

// repeated .openmp.libomptarget.remote.ImagePtrs image_ptrs = 1;
inline int TargetBinaryDescription::_internal_image_ptrs_size() const {
  return _impl_.image_ptrs_.size();
}
inline int TargetBinaryDescription::image_ptrs_size() const {
  return _internal_image_ptrs_size();
}
inline void TargetBinaryDescription::clear_image_ptrs() {
  _impl_.image_ptrs_.Clear();
}
inline ::openmp::libomptarget::remote::ImagePtrs* TargetBinaryDescription::mutable_image_ptrs(int index) {
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.TargetBinaryDescription.image_ptrs)
  return _impl_.image_ptrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::ImagePtrs >*
TargetBinaryDescription::mutable_image_ptrs() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetBinaryDescription.image_ptrs)
  return &_impl_.image_ptrs_;
}
inline const ::openmp::libomptarget::remote::ImagePtrs& TargetBinaryDescription::_internal_image_ptrs(int index) const {
  return _impl_.image_ptrs_.Get(index);
}
inline const ::openmp::libomptarget::remote::ImagePtrs& TargetBinaryDescription::image_ptrs(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetBinaryDescription.image_ptrs)
  return _internal_image_ptrs(index);
}
inline ::openmp::libomptarget::remote::ImagePtrs* TargetBinaryDescription::_internal_add_image_ptrs() {
  return _impl_.image_ptrs_.Add();
}
inline ::openmp::libomptarget::remote::ImagePtrs* TargetBinaryDescription::add_image_ptrs() {
  ::openmp::libomptarget::remote::ImagePtrs* _add = _internal_add_image_ptrs();
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetBinaryDescription.image_ptrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::ImagePtrs >&
TargetBinaryDescription::image_ptrs() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetBinaryDescription.image_ptrs)
  return _impl_.image_ptrs_;
}

// repeated .openmp.libomptarget.remote.TargetOffloadEntry entries = 2;
inline int TargetBinaryDescription::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int TargetBinaryDescription::entries_size() const {
  return _internal_entries_size();
}
inline void TargetBinaryDescription::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::openmp::libomptarget::remote::TargetOffloadEntry* TargetBinaryDescription::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.TargetBinaryDescription.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry >*
TargetBinaryDescription::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetBinaryDescription.entries)
  return &_impl_.entries_;
}
inline const ::openmp::libomptarget::remote::TargetOffloadEntry& TargetBinaryDescription::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::openmp::libomptarget::remote::TargetOffloadEntry& TargetBinaryDescription::entries(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetBinaryDescription.entries)
  return _internal_entries(index);
}
inline ::openmp::libomptarget::remote::TargetOffloadEntry* TargetBinaryDescription::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::openmp::libomptarget::remote::TargetOffloadEntry* TargetBinaryDescription::add_entries() {
  ::openmp::libomptarget::remote::TargetOffloadEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetBinaryDescription.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetOffloadEntry >&
TargetBinaryDescription::entries() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetBinaryDescription.entries)
  return _impl_.entries_;
}

// repeated .openmp.libomptarget.remote.TargetDeviceImage images = 3;
inline int TargetBinaryDescription::_internal_images_size() const {
  return _impl_.images_.size();
}
inline int TargetBinaryDescription::images_size() const {
  return _internal_images_size();
}
inline void TargetBinaryDescription::clear_images() {
  _impl_.images_.Clear();
}
inline ::openmp::libomptarget::remote::TargetDeviceImage* TargetBinaryDescription::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.TargetBinaryDescription.images)
  return _impl_.images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetDeviceImage >*
TargetBinaryDescription::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetBinaryDescription.images)
  return &_impl_.images_;
}
inline const ::openmp::libomptarget::remote::TargetDeviceImage& TargetBinaryDescription::_internal_images(int index) const {
  return _impl_.images_.Get(index);
}
inline const ::openmp::libomptarget::remote::TargetDeviceImage& TargetBinaryDescription::images(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetBinaryDescription.images)
  return _internal_images(index);
}
inline ::openmp::libomptarget::remote::TargetDeviceImage* TargetBinaryDescription::_internal_add_images() {
  return _impl_.images_.Add();
}
inline ::openmp::libomptarget::remote::TargetDeviceImage* TargetBinaryDescription::add_images() {
  ::openmp::libomptarget::remote::TargetDeviceImage* _add = _internal_add_images();
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetBinaryDescription.images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openmp::libomptarget::remote::TargetDeviceImage >&
TargetBinaryDescription::images() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetBinaryDescription.images)
  return _impl_.images_;
}

// repeated uint64 entry_ptrs = 4;
inline int TargetBinaryDescription::_internal_entry_ptrs_size() const {
  return _impl_.entry_ptrs_.size();
}
inline int TargetBinaryDescription::entry_ptrs_size() const {
  return _internal_entry_ptrs_size();
}
inline void TargetBinaryDescription::clear_entry_ptrs() {
  _impl_.entry_ptrs_.Clear();
}
inline uint64_t TargetBinaryDescription::_internal_entry_ptrs(int index) const {
  return _impl_.entry_ptrs_.Get(index);
}
inline uint64_t TargetBinaryDescription::entry_ptrs(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetBinaryDescription.entry_ptrs)
  return _internal_entry_ptrs(index);
}
inline void TargetBinaryDescription::set_entry_ptrs(int index, uint64_t value) {
  _impl_.entry_ptrs_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetBinaryDescription.entry_ptrs)
}
inline void TargetBinaryDescription::_internal_add_entry_ptrs(uint64_t value) {
  _impl_.entry_ptrs_.Add(value);
}
inline void TargetBinaryDescription::add_entry_ptrs(uint64_t value) {
  _internal_add_entry_ptrs(value);
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetBinaryDescription.entry_ptrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetBinaryDescription::_internal_entry_ptrs() const {
  return _impl_.entry_ptrs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetBinaryDescription::entry_ptrs() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetBinaryDescription.entry_ptrs)
  return _internal_entry_ptrs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetBinaryDescription::_internal_mutable_entry_ptrs() {
  return &_impl_.entry_ptrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetBinaryDescription::mutable_entry_ptrs() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetBinaryDescription.entry_ptrs)
  return _internal_mutable_entry_ptrs();
}

// uint64 bin_ptr = 5;
inline void TargetBinaryDescription::clear_bin_ptr() {
  _impl_.bin_ptr_ = uint64_t{0u};
}
inline uint64_t TargetBinaryDescription::_internal_bin_ptr() const {
  return _impl_.bin_ptr_;
}
inline uint64_t TargetBinaryDescription::bin_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetBinaryDescription.bin_ptr)
  return _internal_bin_ptr();
}
inline void TargetBinaryDescription::_internal_set_bin_ptr(uint64_t value) {
  
  _impl_.bin_ptr_ = value;
}
inline void TargetBinaryDescription::set_bin_ptr(uint64_t value) {
  _internal_set_bin_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetBinaryDescription.bin_ptr)
}

// -------------------------------------------------------------------

// AllocData

// uint64 size = 1;
inline void AllocData::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t AllocData::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t AllocData::size() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.AllocData.size)
  return _internal_size();
}
inline void AllocData::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void AllocData::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.AllocData.size)
}

// uint64 hst_ptr = 2;
inline void AllocData::clear_hst_ptr() {
  _impl_.hst_ptr_ = uint64_t{0u};
}
inline uint64_t AllocData::_internal_hst_ptr() const {
  return _impl_.hst_ptr_;
}
inline uint64_t AllocData::hst_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.AllocData.hst_ptr)
  return _internal_hst_ptr();
}
inline void AllocData::_internal_set_hst_ptr(uint64_t value) {
  
  _impl_.hst_ptr_ = value;
}
inline void AllocData::set_hst_ptr(uint64_t value) {
  _internal_set_hst_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.AllocData.hst_ptr)
}

// int32 device_id = 3;
inline void AllocData::clear_device_id() {
  _impl_.device_id_ = 0;
}
inline int32_t AllocData::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t AllocData::device_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.AllocData.device_id)
  return _internal_device_id();
}
inline void AllocData::_internal_set_device_id(int32_t value) {
  
  _impl_.device_id_ = value;
}
inline void AllocData::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.AllocData.device_id)
}

// -------------------------------------------------------------------

// SubmitData

// bytes data = 1;
inline void SubmitData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SubmitData::data() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.SubmitData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitData::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.SubmitData.data)
}
inline std::string* SubmitData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.SubmitData.data)
  return _s;
}
inline const std::string& SubmitData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SubmitData::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitData::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitData::release_data() {
  // @@protoc_insertion_point(field_release:openmp.libomptarget.remote.SubmitData.data)
  return _impl_.data_.Release();
}
inline void SubmitData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmp.libomptarget.remote.SubmitData.data)
}

// uint64 hst_ptr = 2;
inline void SubmitData::clear_hst_ptr() {
  _impl_.hst_ptr_ = uint64_t{0u};
}
inline uint64_t SubmitData::_internal_hst_ptr() const {
  return _impl_.hst_ptr_;
}
inline uint64_t SubmitData::hst_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.SubmitData.hst_ptr)
  return _internal_hst_ptr();
}
inline void SubmitData::_internal_set_hst_ptr(uint64_t value) {
  
  _impl_.hst_ptr_ = value;
}
inline void SubmitData::set_hst_ptr(uint64_t value) {
  _internal_set_hst_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.SubmitData.hst_ptr)
}

// uint64 tgt_ptr = 3;
inline void SubmitData::clear_tgt_ptr() {
  _impl_.tgt_ptr_ = uint64_t{0u};
}
inline uint64_t SubmitData::_internal_tgt_ptr() const {
  return _impl_.tgt_ptr_;
}
inline uint64_t SubmitData::tgt_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.SubmitData.tgt_ptr)
  return _internal_tgt_ptr();
}
inline void SubmitData::_internal_set_tgt_ptr(uint64_t value) {
  
  _impl_.tgt_ptr_ = value;
}
inline void SubmitData::set_tgt_ptr(uint64_t value) {
  _internal_set_tgt_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.SubmitData.tgt_ptr)
}

// uint64 start = 5;
inline void SubmitData::clear_start() {
  _impl_.start_ = uint64_t{0u};
}
inline uint64_t SubmitData::_internal_start() const {
  return _impl_.start_;
}
inline uint64_t SubmitData::start() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.SubmitData.start)
  return _internal_start();
}
inline void SubmitData::_internal_set_start(uint64_t value) {
  
  _impl_.start_ = value;
}
inline void SubmitData::set_start(uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.SubmitData.start)
}

// uint64 size = 6;
inline void SubmitData::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t SubmitData::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t SubmitData::size() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.SubmitData.size)
  return _internal_size();
}
inline void SubmitData::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void SubmitData::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.SubmitData.size)
}

// int32 device_id = 7;
inline void SubmitData::clear_device_id() {
  _impl_.device_id_ = 0;
}
inline int32_t SubmitData::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t SubmitData::device_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.SubmitData.device_id)
  return _internal_device_id();
}
inline void SubmitData::_internal_set_device_id(int32_t value) {
  
  _impl_.device_id_ = value;
}
inline void SubmitData::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.SubmitData.device_id)
}

// -------------------------------------------------------------------

// RetrieveData

// uint64 hst_ptr = 1;
inline void RetrieveData::clear_hst_ptr() {
  _impl_.hst_ptr_ = uint64_t{0u};
}
inline uint64_t RetrieveData::_internal_hst_ptr() const {
  return _impl_.hst_ptr_;
}
inline uint64_t RetrieveData::hst_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.RetrieveData.hst_ptr)
  return _internal_hst_ptr();
}
inline void RetrieveData::_internal_set_hst_ptr(uint64_t value) {
  
  _impl_.hst_ptr_ = value;
}
inline void RetrieveData::set_hst_ptr(uint64_t value) {
  _internal_set_hst_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.RetrieveData.hst_ptr)
}

// uint64 tgt_ptr = 2;
inline void RetrieveData::clear_tgt_ptr() {
  _impl_.tgt_ptr_ = uint64_t{0u};
}
inline uint64_t RetrieveData::_internal_tgt_ptr() const {
  return _impl_.tgt_ptr_;
}
inline uint64_t RetrieveData::tgt_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.RetrieveData.tgt_ptr)
  return _internal_tgt_ptr();
}
inline void RetrieveData::_internal_set_tgt_ptr(uint64_t value) {
  
  _impl_.tgt_ptr_ = value;
}
inline void RetrieveData::set_tgt_ptr(uint64_t value) {
  _internal_set_tgt_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.RetrieveData.tgt_ptr)
}

// uint64 size = 3;
inline void RetrieveData::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t RetrieveData::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t RetrieveData::size() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.RetrieveData.size)
  return _internal_size();
}
inline void RetrieveData::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void RetrieveData::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.RetrieveData.size)
}

// int32 device_id = 5;
inline void RetrieveData::clear_device_id() {
  _impl_.device_id_ = 0;
}
inline int32_t RetrieveData::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t RetrieveData::device_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.RetrieveData.device_id)
  return _internal_device_id();
}
inline void RetrieveData::_internal_set_device_id(int32_t value) {
  
  _impl_.device_id_ = value;
}
inline void RetrieveData::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.RetrieveData.device_id)
}

// -------------------------------------------------------------------

// Data

// bytes data = 1;
inline void Data::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Data::data() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.Data.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Data::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.Data.data)
}
inline std::string* Data::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:openmp.libomptarget.remote.Data.data)
  return _s;
}
inline const std::string& Data::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Data::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Data::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Data::release_data() {
  // @@protoc_insertion_point(field_release:openmp.libomptarget.remote.Data.data)
  return _impl_.data_.Release();
}
inline void Data::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openmp.libomptarget.remote.Data.data)
}

// uint64 start = 2;
inline void Data::clear_start() {
  _impl_.start_ = uint64_t{0u};
}
inline uint64_t Data::_internal_start() const {
  return _impl_.start_;
}
inline uint64_t Data::start() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.Data.start)
  return _internal_start();
}
inline void Data::_internal_set_start(uint64_t value) {
  
  _impl_.start_ = value;
}
inline void Data::set_start(uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.Data.start)
}

// uint64 size = 3;
inline void Data::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t Data::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t Data::size() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.Data.size)
  return _internal_size();
}
inline void Data::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void Data::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.Data.size)
}

// int32 ret = 4;
inline void Data::clear_ret() {
  _impl_.ret_ = 0;
}
inline int32_t Data::_internal_ret() const {
  return _impl_.ret_;
}
inline int32_t Data::ret() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.Data.ret)
  return _internal_ret();
}
inline void Data::_internal_set_ret(int32_t value) {
  
  _impl_.ret_ = value;
}
inline void Data::set_ret(int32_t value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.Data.ret)
}

// -------------------------------------------------------------------

// ExchangeData

// uint64 src_dev_id = 1;
inline void ExchangeData::clear_src_dev_id() {
  _impl_.src_dev_id_ = uint64_t{0u};
}
inline uint64_t ExchangeData::_internal_src_dev_id() const {
  return _impl_.src_dev_id_;
}
inline uint64_t ExchangeData::src_dev_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.ExchangeData.src_dev_id)
  return _internal_src_dev_id();
}
inline void ExchangeData::_internal_set_src_dev_id(uint64_t value) {
  
  _impl_.src_dev_id_ = value;
}
inline void ExchangeData::set_src_dev_id(uint64_t value) {
  _internal_set_src_dev_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.ExchangeData.src_dev_id)
}

// uint64 src_ptr = 2;
inline void ExchangeData::clear_src_ptr() {
  _impl_.src_ptr_ = uint64_t{0u};
}
inline uint64_t ExchangeData::_internal_src_ptr() const {
  return _impl_.src_ptr_;
}
inline uint64_t ExchangeData::src_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.ExchangeData.src_ptr)
  return _internal_src_ptr();
}
inline void ExchangeData::_internal_set_src_ptr(uint64_t value) {
  
  _impl_.src_ptr_ = value;
}
inline void ExchangeData::set_src_ptr(uint64_t value) {
  _internal_set_src_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.ExchangeData.src_ptr)
}

// uint64 dst_dev_id = 3;
inline void ExchangeData::clear_dst_dev_id() {
  _impl_.dst_dev_id_ = uint64_t{0u};
}
inline uint64_t ExchangeData::_internal_dst_dev_id() const {
  return _impl_.dst_dev_id_;
}
inline uint64_t ExchangeData::dst_dev_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.ExchangeData.dst_dev_id)
  return _internal_dst_dev_id();
}
inline void ExchangeData::_internal_set_dst_dev_id(uint64_t value) {
  
  _impl_.dst_dev_id_ = value;
}
inline void ExchangeData::set_dst_dev_id(uint64_t value) {
  _internal_set_dst_dev_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.ExchangeData.dst_dev_id)
}

// uint64 dst_ptr = 4;
inline void ExchangeData::clear_dst_ptr() {
  _impl_.dst_ptr_ = uint64_t{0u};
}
inline uint64_t ExchangeData::_internal_dst_ptr() const {
  return _impl_.dst_ptr_;
}
inline uint64_t ExchangeData::dst_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.ExchangeData.dst_ptr)
  return _internal_dst_ptr();
}
inline void ExchangeData::_internal_set_dst_ptr(uint64_t value) {
  
  _impl_.dst_ptr_ = value;
}
inline void ExchangeData::set_dst_ptr(uint64_t value) {
  _internal_set_dst_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.ExchangeData.dst_ptr)
}

// uint64 size = 6;
inline void ExchangeData::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t ExchangeData::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t ExchangeData::size() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.ExchangeData.size)
  return _internal_size();
}
inline void ExchangeData::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void ExchangeData::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.ExchangeData.size)
}

// -------------------------------------------------------------------

// DeleteData

// uint64 tgt_ptr = 1;
inline void DeleteData::clear_tgt_ptr() {
  _impl_.tgt_ptr_ = uint64_t{0u};
}
inline uint64_t DeleteData::_internal_tgt_ptr() const {
  return _impl_.tgt_ptr_;
}
inline uint64_t DeleteData::tgt_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DeleteData.tgt_ptr)
  return _internal_tgt_ptr();
}
inline void DeleteData::_internal_set_tgt_ptr(uint64_t value) {
  
  _impl_.tgt_ptr_ = value;
}
inline void DeleteData::set_tgt_ptr(uint64_t value) {
  _internal_set_tgt_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DeleteData.tgt_ptr)
}

// int32 device_id = 2;
inline void DeleteData::clear_device_id() {
  _impl_.device_id_ = 0;
}
inline int32_t DeleteData::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t DeleteData::device_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.DeleteData.device_id)
  return _internal_device_id();
}
inline void DeleteData::_internal_set_device_id(int32_t value) {
  
  _impl_.device_id_ = value;
}
inline void DeleteData::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.DeleteData.device_id)
}

// -------------------------------------------------------------------

// TargetRegion

// repeated uint64 tgt_args = 1;
inline int TargetRegion::_internal_tgt_args_size() const {
  return _impl_.tgt_args_.size();
}
inline int TargetRegion::tgt_args_size() const {
  return _internal_tgt_args_size();
}
inline void TargetRegion::clear_tgt_args() {
  _impl_.tgt_args_.Clear();
}
inline uint64_t TargetRegion::_internal_tgt_args(int index) const {
  return _impl_.tgt_args_.Get(index);
}
inline uint64_t TargetRegion::tgt_args(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetRegion.tgt_args)
  return _internal_tgt_args(index);
}
inline void TargetRegion::set_tgt_args(int index, uint64_t value) {
  _impl_.tgt_args_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetRegion.tgt_args)
}
inline void TargetRegion::_internal_add_tgt_args(uint64_t value) {
  _impl_.tgt_args_.Add(value);
}
inline void TargetRegion::add_tgt_args(uint64_t value) {
  _internal_add_tgt_args(value);
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetRegion.tgt_args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetRegion::_internal_tgt_args() const {
  return _impl_.tgt_args_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetRegion::tgt_args() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetRegion.tgt_args)
  return _internal_tgt_args();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetRegion::_internal_mutable_tgt_args() {
  return &_impl_.tgt_args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetRegion::mutable_tgt_args() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetRegion.tgt_args)
  return _internal_mutable_tgt_args();
}

// repeated int64 tgt_offsets = 2;
inline int TargetRegion::_internal_tgt_offsets_size() const {
  return _impl_.tgt_offsets_.size();
}
inline int TargetRegion::tgt_offsets_size() const {
  return _internal_tgt_offsets_size();
}
inline void TargetRegion::clear_tgt_offsets() {
  _impl_.tgt_offsets_.Clear();
}
inline int64_t TargetRegion::_internal_tgt_offsets(int index) const {
  return _impl_.tgt_offsets_.Get(index);
}
inline int64_t TargetRegion::tgt_offsets(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetRegion.tgt_offsets)
  return _internal_tgt_offsets(index);
}
inline void TargetRegion::set_tgt_offsets(int index, int64_t value) {
  _impl_.tgt_offsets_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetRegion.tgt_offsets)
}
inline void TargetRegion::_internal_add_tgt_offsets(int64_t value) {
  _impl_.tgt_offsets_.Add(value);
}
inline void TargetRegion::add_tgt_offsets(int64_t value) {
  _internal_add_tgt_offsets(value);
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetRegion.tgt_offsets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TargetRegion::_internal_tgt_offsets() const {
  return _impl_.tgt_offsets_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TargetRegion::tgt_offsets() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetRegion.tgt_offsets)
  return _internal_tgt_offsets();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TargetRegion::_internal_mutable_tgt_offsets() {
  return &_impl_.tgt_offsets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TargetRegion::mutable_tgt_offsets() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetRegion.tgt_offsets)
  return _internal_mutable_tgt_offsets();
}

// uint64 tgt_entry_ptr = 3;
inline void TargetRegion::clear_tgt_entry_ptr() {
  _impl_.tgt_entry_ptr_ = uint64_t{0u};
}
inline uint64_t TargetRegion::_internal_tgt_entry_ptr() const {
  return _impl_.tgt_entry_ptr_;
}
inline uint64_t TargetRegion::tgt_entry_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetRegion.tgt_entry_ptr)
  return _internal_tgt_entry_ptr();
}
inline void TargetRegion::_internal_set_tgt_entry_ptr(uint64_t value) {
  
  _impl_.tgt_entry_ptr_ = value;
}
inline void TargetRegion::set_tgt_entry_ptr(uint64_t value) {
  _internal_set_tgt_entry_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetRegion.tgt_entry_ptr)
}

// int32 device_id = 4;
inline void TargetRegion::clear_device_id() {
  _impl_.device_id_ = 0;
}
inline int32_t TargetRegion::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t TargetRegion::device_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetRegion.device_id)
  return _internal_device_id();
}
inline void TargetRegion::_internal_set_device_id(int32_t value) {
  
  _impl_.device_id_ = value;
}
inline void TargetRegion::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetRegion.device_id)
}

// int32 arg_num = 5;
inline void TargetRegion::clear_arg_num() {
  _impl_.arg_num_ = 0;
}
inline int32_t TargetRegion::_internal_arg_num() const {
  return _impl_.arg_num_;
}
inline int32_t TargetRegion::arg_num() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetRegion.arg_num)
  return _internal_arg_num();
}
inline void TargetRegion::_internal_set_arg_num(int32_t value) {
  
  _impl_.arg_num_ = value;
}
inline void TargetRegion::set_arg_num(int32_t value) {
  _internal_set_arg_num(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetRegion.arg_num)
}

// -------------------------------------------------------------------

// TargetTeamRegion

// repeated uint64 tgt_args = 1;
inline int TargetTeamRegion::_internal_tgt_args_size() const {
  return _impl_.tgt_args_.size();
}
inline int TargetTeamRegion::tgt_args_size() const {
  return _internal_tgt_args_size();
}
inline void TargetTeamRegion::clear_tgt_args() {
  _impl_.tgt_args_.Clear();
}
inline uint64_t TargetTeamRegion::_internal_tgt_args(int index) const {
  return _impl_.tgt_args_.Get(index);
}
inline uint64_t TargetTeamRegion::tgt_args(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTeamRegion.tgt_args)
  return _internal_tgt_args(index);
}
inline void TargetTeamRegion::set_tgt_args(int index, uint64_t value) {
  _impl_.tgt_args_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTeamRegion.tgt_args)
}
inline void TargetTeamRegion::_internal_add_tgt_args(uint64_t value) {
  _impl_.tgt_args_.Add(value);
}
inline void TargetTeamRegion::add_tgt_args(uint64_t value) {
  _internal_add_tgt_args(value);
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetTeamRegion.tgt_args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetTeamRegion::_internal_tgt_args() const {
  return _impl_.tgt_args_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TargetTeamRegion::tgt_args() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetTeamRegion.tgt_args)
  return _internal_tgt_args();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetTeamRegion::_internal_mutable_tgt_args() {
  return &_impl_.tgt_args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TargetTeamRegion::mutable_tgt_args() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetTeamRegion.tgt_args)
  return _internal_mutable_tgt_args();
}

// repeated int64 tgt_offsets = 2;
inline int TargetTeamRegion::_internal_tgt_offsets_size() const {
  return _impl_.tgt_offsets_.size();
}
inline int TargetTeamRegion::tgt_offsets_size() const {
  return _internal_tgt_offsets_size();
}
inline void TargetTeamRegion::clear_tgt_offsets() {
  _impl_.tgt_offsets_.Clear();
}
inline int64_t TargetTeamRegion::_internal_tgt_offsets(int index) const {
  return _impl_.tgt_offsets_.Get(index);
}
inline int64_t TargetTeamRegion::tgt_offsets(int index) const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTeamRegion.tgt_offsets)
  return _internal_tgt_offsets(index);
}
inline void TargetTeamRegion::set_tgt_offsets(int index, int64_t value) {
  _impl_.tgt_offsets_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTeamRegion.tgt_offsets)
}
inline void TargetTeamRegion::_internal_add_tgt_offsets(int64_t value) {
  _impl_.tgt_offsets_.Add(value);
}
inline void TargetTeamRegion::add_tgt_offsets(int64_t value) {
  _internal_add_tgt_offsets(value);
  // @@protoc_insertion_point(field_add:openmp.libomptarget.remote.TargetTeamRegion.tgt_offsets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TargetTeamRegion::_internal_tgt_offsets() const {
  return _impl_.tgt_offsets_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TargetTeamRegion::tgt_offsets() const {
  // @@protoc_insertion_point(field_list:openmp.libomptarget.remote.TargetTeamRegion.tgt_offsets)
  return _internal_tgt_offsets();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TargetTeamRegion::_internal_mutable_tgt_offsets() {
  return &_impl_.tgt_offsets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TargetTeamRegion::mutable_tgt_offsets() {
  // @@protoc_insertion_point(field_mutable_list:openmp.libomptarget.remote.TargetTeamRegion.tgt_offsets)
  return _internal_mutable_tgt_offsets();
}

// uint64 tgt_entry_ptr = 3;
inline void TargetTeamRegion::clear_tgt_entry_ptr() {
  _impl_.tgt_entry_ptr_ = uint64_t{0u};
}
inline uint64_t TargetTeamRegion::_internal_tgt_entry_ptr() const {
  return _impl_.tgt_entry_ptr_;
}
inline uint64_t TargetTeamRegion::tgt_entry_ptr() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTeamRegion.tgt_entry_ptr)
  return _internal_tgt_entry_ptr();
}
inline void TargetTeamRegion::_internal_set_tgt_entry_ptr(uint64_t value) {
  
  _impl_.tgt_entry_ptr_ = value;
}
inline void TargetTeamRegion::set_tgt_entry_ptr(uint64_t value) {
  _internal_set_tgt_entry_ptr(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTeamRegion.tgt_entry_ptr)
}

// uint64 loop_tripcount = 4;
inline void TargetTeamRegion::clear_loop_tripcount() {
  _impl_.loop_tripcount_ = uint64_t{0u};
}
inline uint64_t TargetTeamRegion::_internal_loop_tripcount() const {
  return _impl_.loop_tripcount_;
}
inline uint64_t TargetTeamRegion::loop_tripcount() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTeamRegion.loop_tripcount)
  return _internal_loop_tripcount();
}
inline void TargetTeamRegion::_internal_set_loop_tripcount(uint64_t value) {
  
  _impl_.loop_tripcount_ = value;
}
inline void TargetTeamRegion::set_loop_tripcount(uint64_t value) {
  _internal_set_loop_tripcount(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTeamRegion.loop_tripcount)
}

// int32 device_id = 5;
inline void TargetTeamRegion::clear_device_id() {
  _impl_.device_id_ = 0;
}
inline int32_t TargetTeamRegion::_internal_device_id() const {
  return _impl_.device_id_;
}
inline int32_t TargetTeamRegion::device_id() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTeamRegion.device_id)
  return _internal_device_id();
}
inline void TargetTeamRegion::_internal_set_device_id(int32_t value) {
  
  _impl_.device_id_ = value;
}
inline void TargetTeamRegion::set_device_id(int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTeamRegion.device_id)
}

// int32 arg_num = 6;
inline void TargetTeamRegion::clear_arg_num() {
  _impl_.arg_num_ = 0;
}
inline int32_t TargetTeamRegion::_internal_arg_num() const {
  return _impl_.arg_num_;
}
inline int32_t TargetTeamRegion::arg_num() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTeamRegion.arg_num)
  return _internal_arg_num();
}
inline void TargetTeamRegion::_internal_set_arg_num(int32_t value) {
  
  _impl_.arg_num_ = value;
}
inline void TargetTeamRegion::set_arg_num(int32_t value) {
  _internal_set_arg_num(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTeamRegion.arg_num)
}

// int32 team_num = 7;
inline void TargetTeamRegion::clear_team_num() {
  _impl_.team_num_ = 0;
}
inline int32_t TargetTeamRegion::_internal_team_num() const {
  return _impl_.team_num_;
}
inline int32_t TargetTeamRegion::team_num() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTeamRegion.team_num)
  return _internal_team_num();
}
inline void TargetTeamRegion::_internal_set_team_num(int32_t value) {
  
  _impl_.team_num_ = value;
}
inline void TargetTeamRegion::set_team_num(int32_t value) {
  _internal_set_team_num(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTeamRegion.team_num)
}

// int32 thread_limit = 8;
inline void TargetTeamRegion::clear_thread_limit() {
  _impl_.thread_limit_ = 0;
}
inline int32_t TargetTeamRegion::_internal_thread_limit() const {
  return _impl_.thread_limit_;
}
inline int32_t TargetTeamRegion::thread_limit() const {
  // @@protoc_insertion_point(field_get:openmp.libomptarget.remote.TargetTeamRegion.thread_limit)
  return _internal_thread_limit();
}
inline void TargetTeamRegion::_internal_set_thread_limit(int32_t value) {
  
  _impl_.thread_limit_ = value;
}
inline void TargetTeamRegion::set_thread_limit(int32_t value) {
  _internal_set_thread_limit(value);
  // @@protoc_insertion_point(field_set:openmp.libomptarget.remote.TargetTeamRegion.thread_limit)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace remote
}  // namespace libomptarget
}  // namespace openmp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openmp_2eproto
